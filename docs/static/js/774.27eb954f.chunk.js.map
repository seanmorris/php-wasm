{"version":3,"file":"static/js/774.27eb954f.chunk.js","mappings":"8JAAAA,EAAAA,EAAAA,KAsBA,IAtBAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAwBMC,EACC,MADDA,EAEE,MA2CKC,EAAN,cAAwBC,EAAAA,EA0B7BC,WAAAA,CACEC,GAMA,IAJEC,gBAAAC,EAAkB,IAClBC,mBAAAC,EAAqB,IACrBC,MAAAC,GAAQ,GACVC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAoB,CAAC,EAErBG,MAAMV,EAAS,CAAEK,MAAAC,KAlCdK,EAAAA,EAAAA,GAAA,KAAAxB,IAKLwB,EAAAA,EAAAA,GAAA,KAAAnC,IACAmC,EAAAA,EAAAA,GAAA,KAAAlC,IACAkC,EAAAA,EAAAA,GAAA,KAAAjC,IAEAiC,EAAAA,EAAAA,GAAA,KAAAhC,IACAgC,EAAAA,EAAAA,GAAA,KAAA/B,IAEA+B,EAAAA,EAAAA,GAAA,KAAA9B,EAAyC,IAAI+B,MAC7CD,EAAAA,EAAAA,GAAA,KAAA7B,EAA+C,IAAI8B,MAEnDD,EAAAA,EAAAA,GAAA,KAAA5B,EAAmB,IACnB4B,EAAAA,EAAAA,GAAA,KAAA3B,EAAwC,IAAI4B,MAC5CD,EAAAA,EAAAA,GAAA,KAAA1B,EAAsC,IAAI2B,KAG1C,KAAAC,eAAiB,EACjB,KAAAC,mBAAqB,IACrB,KAAAC,YAAc,GAEdJ,EAAAA,EAAAA,GAAA,KAAAzB,EAAc,IAAI8B,KAWhBC,KAAKhB,gBAAkBC,EACvBe,KAAKd,mBAAqBC,CAC5B,CAEA,UAAMc,CAAKlB,EAAYE,GACrB,aAAMiB,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAC,GAALgC,KAAAH,MACCP,MAAMQ,KAAKlB,EAAIE,EACxB,CAEA,cAAMmB,GAAoC,IAA3BrB,EAAAO,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,SACPU,KAAKK,6BACLL,KAAKM,eACNvB,GACHiB,KAAKO,OAET,CAEA,aAAMC,GACJ,IAAK,IAAMzB,KAAM0B,EAAAA,EAAAA,GAAAT,KAAKnC,GAAI6C,SACxB3B,EAAG4B,SAELF,EAAAA,EAAAA,GAAAT,KAAKrC,GAAS4C,SACdE,EAAAA,EAAAA,GAAAT,KAAKrC,GAASgD,QACdX,KAAKY,GAAIC,OAAOC,GAAGC,MACrB,CAiHA,kBAAMT,CAAavB,GAEjB,IAAME,GADNF,EAAOA,GAAQiB,KAAKd,oBACEc,KAAKgB,MAAMC,KAAK1B,OAChCJ,EAA4B,GAClC,IAAK,IAAIE,EAAI,EAAGA,EAAIJ,EAAQI,IAC1BF,EAAS+B,KAEP,IAAIC,QAAcC,YACdpB,KAAKF,YACP,IAAMuB,EAAA,GAAAC,QAAeC,KAAKC,MAAQ,YAAYC,SAAS,IAAIC,SAAS,EAAG,KAAI,KAAAJ,OAAItB,KAAKF,YAAY2B,SAAS,IAAIC,SAAS,EAAG,MACnHC,QAAWlB,EAAAA,EAAAA,GAAAT,KAAKvC,GAAWmE,cAAcP,EAAU,CACvDQ,QAAQ,IAEJC,QACJH,EACAI,0BACFtB,EAAAA,EAAAA,GAAAT,KAAKpC,GAAIoE,IAAIX,EAAUM,IACvBlB,EAAAA,EAAAA,GAAAT,KAAKnC,GAAImE,IAAIX,EAAUS,IACvB5B,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAG,GAAL8B,KAAAH,KAAa,CACXiC,IAAK,iBACLC,KAAM,CAACb,KAETrB,KAAKgB,MAAMC,KAAKC,KAAKG,GACrBc,OAIN,IAAK,IAAI9C,EAAI,EAAGA,EAAIJ,EAAQI,IAC1BF,EAAS+B,KAEP,IAAIC,QAAcC,UAAmB,IAAAgB,EACnC,IAAMf,EAAWrB,KAAKgB,MAAMC,KAAKoB,OACjCnC,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAG,GAAL8B,KAAAH,KAAa,CACXiC,IAAK,iBACLC,KAAM,CAACb,KAET,IAAMM,GAAKlB,EAAAA,EAAAA,GAAAT,KAAKpC,GAAI0E,IAAIjB,GACQ,QAArBe,GAAA3B,EAAAA,EAAAA,GAAAT,KAAKnC,GAAIyE,IAAIjB,UAAQ,IAAAe,GAArBA,EACPzB,cACEF,EAAAA,EAAAA,GAAAT,KAAKvC,GAAW8E,YAAYZ,EAAGa,OACrC/B,EAAAA,EAAAA,GAAAT,KAAKpC,GAAI6E,OAAOpB,IAChBZ,EAAAA,EAAAA,GAAAT,KAAKnC,GAAI4E,OAAOpB,GAChBc,aAIAhB,QAAQuB,IAAIvD,EACpB,CAEAwD,oBAAAA,CAAqB5D,GACnBiB,KAAKgB,MAAMC,KAAKC,KAAKnC,EACvB,CAEA6D,oBAAAA,CAAqB7D,GACnB,IAAME,EAAQe,KAAKgB,MAAMC,KAAK4B,QAAQ9D,GAClCE,GAAS,GACXe,KAAKgB,MAAMC,KAAK6B,OAAO7D,EAAO,EAElC,CAEA,0BAAMoB,GACAkB,KAAKC,MAAQxB,KAAKJ,eAAiBI,KAAKH,0BACpCG,KAAK+C,iBAEf,CAEA,qBAAMA,GACJ,IAAMhE,GAAU,IAAIiE,aAAcC,OAAOC,KAAKC,UAAUnD,KAAKgB,SAC7DP,EAAAA,EAAAA,GAAAT,KAAKrC,GAASyF,SAAS,IACvB3C,EAAAA,EAAAA,GAAAT,KAAKrC,GAAS0F,MAAMtE,EAAS,CAAEuE,GAAI,KACnC7C,EAAAA,EAAAA,GAAAT,KAAKrC,GAAS4C,QACdP,KAAKJ,eAAiB2B,KAAKC,KAC7B,CAEAjB,KAAAA,GACE,IAAK,IAAMxB,KAAM0B,EAAAA,EAAAA,GAAAT,KAAK/B,GACpB,IACEc,EAAGwB,OACL,CAAE,MAAFgD,GAEA,EAEF9C,EAAAA,EAAAA,GAAAT,KAAK/B,GAAYuF,OACnB,CAIAC,KAAAA,CAAM1E,EAAcE,IAClBiB,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAE,GAAL+B,KAAAH,KAAiB,CAAEiC,IAAK,QAASC,KAAM,CAACnD,EAAME,IAAS,KACrDe,KAAK0D,YAAY3E,EAAME,IAE3B,CAEAyE,WAAAA,CAAY3E,EAAcE,IACXiB,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAK,GAAL4B,KAAAH,KAAkBjB,GAC1B4E,KAAO1E,CACd,CAEA0B,KAAAA,CAAM5B,GACJ,IAAME,GAAOiB,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAM,GAAL2B,KAAAH,KAAoBjB,IACjC0B,EAAAA,EAAAA,GAAAT,KAAKjC,GAAiB0E,OAAO1D,IAC7B0B,EAAAA,EAAAA,GAAAT,KAAKhC,GAAeyE,OAAOxD,EAC7B,CAEA2E,KAAAA,CAAM7E,GACJ,IAAME,GAAOiB,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAM,GAAL2B,KAAAH,KAAoBjB,GACjC,OAAOiB,KAAK6D,MAAM5E,EACpB,CAEA4E,KAAAA,CAAM9E,GACJ,IAAME,GAAOiB,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAK,GAAL4B,KAAAH,KAAkBjB,GACzBI,EACU,SAAdF,EAAK6E,MAAkBrD,EAAAA,EAAAA,GAAAT,KAAKnC,GAAIyE,IAAIrD,EAAK8E,iBAAkBC,UAAY,EAEzE,MAAO,CACLC,IAAK,EACLC,IAAK,EACLP,KAAM1E,EAAK0E,KACXQ,MAAO,EACPC,IAAK,EACLC,IAAK,EACLC,KAAM,EACNC,KAAApF,EACAqF,QAVc,KAWdC,OAAQC,KAAKC,KAAKxF,EAXJ,MAYdyF,MAAO3F,EAAK4F,aACZC,MAAO7F,EAAK4F,aACZE,MAAO9F,EAAK4F,aAEhB,CAEAG,KAAAA,CAAMjG,EAAcE,IAClBiB,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAE,GAAL+B,KAAAH,KAAiB,CAAEiC,IAAK,QAASC,KAAM,CAACnD,EAAME,IAAY,KACxDe,KAAKiF,YAAYlG,EAAME,IAE3B,CAEAgG,WAAAA,CACElG,EACAE,GAEA,IAAME,GAAQe,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAI,GAAL6B,KAAAH,KAAgBjB,GACxBM,EAAaF,EAAMkD,MACnBF,EAAwB,GAC1Bd,EAAOrB,KAAKgB,MAAMkE,KACtB,IAAK,IAAMpD,KAAQ3C,EAAO,CAExB,GADAgD,EAAYjB,KAAKnC,IACZoG,OAAOC,UAAUC,eAAelF,KAAKkB,EAAKiE,SAAUxD,GACvD,IAAI,OAAA7C,QAAA,IAAAA,IAAAA,EAASsG,UAGX,MAAM,IAAIC,EAAQ,SAAU,6BAF5BxF,KAAKgF,MAAM7C,EAAYsD,KAAK,KAE4B,CAG5D,GAAiC,cAA7BpE,EAAKiE,SAASxD,GAAMgC,KACtB,MAAM,IAAI0B,EAAQ,UAAW,mBAE/BnE,EAAOA,EAAKiE,SAASxD,EACvB,CACA,GAAIqD,OAAOC,UAAUC,eAAelF,KAAKkB,EAAKiE,SAAUjG,GACtD,MAAM,IAAImG,EAAQ,SAAU,eAE9B,IAAM7D,EAAwB,CAC5BmC,KAAM,YACNe,aAActD,KAAKC,MACnBmC,MAAM,OAAA1E,QAAA,IAAAA,OAAA,EAAAA,EAAS0E,OAAQhF,EACvB2G,SAAU,CAAC,GAEbjE,EAAKiE,SAASjG,GAAcsC,CAC9B,CAEA+D,IAAAA,CAAK3G,EAAcE,EAAiBE,GAElC,GAAkB,UADLe,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAK,GAAL4B,KAAAH,KAAkBjB,GACtB+E,KACP,MAAM,IAAI0B,EAAQ,SAAU,kBAE9B,IAAMrD,GAAWjC,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAO,GAAL0B,KAAAH,MACjB,OAAAS,EAAAA,EAAAA,GAAAT,KAAKjC,GAAiBiE,IAAIG,EAAUpD,IACpC0B,EAAAA,EAAAA,GAAAT,KAAKhC,GAAegE,IAAIjD,EAAMoD,GACvBA,CACT,CAEAwD,OAAAA,CAAQ5G,GACN,IAAME,GAAOiB,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAK,GAAL4B,KAAAH,KAAkBjB,GAC/B,GAAkB,cAAdE,EAAK6E,KACP,MAAM,IAAI0B,EAAQ,UAAW,mBAE/B,OAAOL,OAAOS,KAAK3G,EAAKqG,SAC1B,CAEAO,IAAAA,CACE9G,EACAE,EACAE,EACAE,EACA8C,GAEA,IAAMd,GAAOnB,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAM,GAAL2B,KAAAH,KAAoBjB,GAC3B4C,GAAOzB,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAK,GAAL4B,KAAAH,KAAkBqB,GAC/B,GAAkB,SAAdM,EAAKmC,KACP,MAAM,IAAI0B,EAAQ,SAAU,kBAG9B,OADW/E,EAAAA,EAAAA,GAAAT,KAAKnC,GAAIyE,IAAIX,EAAKoC,iBACnB8B,KAAK,IAAIC,WAAW7G,EAAO8G,OAAQ5G,EAAQE,GAAS,CAC5DiE,GAAInB,GAER,CAEA6D,MAAAA,CAAOjH,EAAiBE,IACtBiB,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAE,GAAL+B,KAAAH,KAAiB,CAAEiC,IAAK,SAAUC,KAAM,CAACnD,EAASE,IAAY,KAC5De,KAAKiG,aAAalH,EAASE,GAAS,IAExC,CAEAgH,YAAAA,CAAalH,EAAiBE,GAA0C,IAAzBE,EAAAG,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GACvCD,GAAea,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAI,GAAL6B,KAAAH,KAAgBjB,GAC/BoD,EAAc9C,EAAagD,MAC3BhB,GAAYnB,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAK,GAAL4B,KAAAH,KAAkBX,EAAaoG,KAAK,MACtD,IACGN,OAAOC,UAAUC,eAAelF,KAAKkB,EAAUiE,SAAUnD,GAE1D,MAAM,IAAIqD,EAAQ,SAAU,6BAE9B,IAAM7D,GAAezB,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAI,GAAL6B,KAAAH,KAAgBf,GAC/B6C,EAAcH,EAAaU,MAC3B6D,GAAYhG,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAK,GAAL4B,KAAAH,KAAkB2B,EAAa8D,KAAK,MACtD,GACEtG,GACAgG,OAAOC,UAAUC,eAAelF,KAAK+F,EAAUZ,SAAUxD,GACzD,CAEA,IAAMqE,EAAOD,EAAUZ,SAASxD,IACrBrB,EAAAA,EAAAA,GAAAT,KAAKnC,GAAIyE,IAAI6D,EAAKpC,iBAC1BX,SAAS,GACZpD,KAAKgB,MAAMC,KAAKC,KAAKiF,EAAKpC,gBAC5B,CACAmC,EAAUZ,SAASxD,GAAeT,EAAUiE,SAASnD,UAC9Cd,EAAUiE,SAASnD,EAC5B,CAEAiE,KAAAA,CAAMrH,IACJmB,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAE,GAAL+B,KAAAH,KAAiB,CAAEiC,IAAK,QAASC,KAAM,CAACnD,IAAS,KAC/CiB,KAAKqG,YAAYtH,IAErB,CAEAsH,WAAAA,CAAYtH,GACV,IAAME,GAAYiB,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAI,GAAL6B,KAAAH,KAAgBjB,GAC5BI,EAAUF,EAAUoD,MACpBhD,GAASa,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAK,GAAL4B,KAAAH,KAAkBf,EAAUwG,KAAK,MAChD,IAAKN,OAAOC,UAAUC,eAAelF,KAAKd,EAAOiG,SAAUnG,GACzD,MAAM,IAAIqG,EAAQ,SAAU,6BAE9B,IAAMrD,EAAO9C,EAAOiG,SAASnG,GAC7B,GAAkB,cAAdgD,EAAK2B,KACP,MAAM,IAAI0B,EAAQ,UAAW,mBAE/B,GAAIL,OAAOS,KAAKzD,EAAKmD,UAAU/F,OAAS,EACtC,MAAM,IAAIiG,EAAQ,YAAa,8BAE1BnG,EAAOiG,SAASnG,EACzB,CAEAiE,QAAAA,CAASrE,GAA6B,IAAfE,EAAAK,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAM,EACrBH,GAAOe,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAK,GAAL4B,KAAAH,KAAkBjB,GAC/B,GAAkB,SAAdI,EAAK2E,KACP,MAAM,IAAI0B,EAAQ,SAAU,kBAE9B,IAAMnG,GAAKoB,EAAAA,EAAAA,GAAAT,KAAKnC,GAAIyE,IAAInD,EAAK4E,iBAC7B,IAAK1E,EACH,MAAM,IAAImG,EAAQ,SAAU,6BAE9BnG,EAAG+D,SAASnE,IACZwB,EAAAA,EAAAA,GAAAT,KAAK/B,GAAYqI,IAAIjH,EACvB,CAEAkH,MAAAA,CAAOxH,IACLmB,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAE,GAAL+B,KAAAH,KAAiB,CAAEiC,IAAK,SAAUC,KAAM,CAACnD,IAAS,KAChDiB,KAAKwG,aAAazH,GAAM,IAE5B,CAEAyH,YAAAA,CAAazH,GAAuC,IAAzBE,EAAAK,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GACnBH,GAAYe,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAI,GAAL6B,KAAAH,KAAgBjB,GAC5BM,EAAWF,EAAUkD,MACrBF,GAAMjC,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAK,GAAL4B,KAAAH,KAAkBb,EAAUsG,KAAK,MAC7C,IAAKN,OAAOC,UAAUC,eAAelF,KAAKgC,EAAImD,SAAUjG,GACtD,MAAM,IAAImG,EAAQ,SAAU,6BAE9B,IAAMnE,EAAOc,EAAImD,SAASjG,GAC1B,GAAkB,SAAdgC,EAAKyC,KACP,MAAM,IAAI0B,EAAQ,SAAU,kBAG9B,UADOrD,EAAImD,SAASjG,GAChBJ,EAAW,CACb,IAAM0C,GAAKlB,EAAAA,EAAAA,GAAAT,KAAKnC,GAAIyE,IAAIjB,EAAK0C,iBAE7B,OAAApC,QAAA,IAAAA,GAAAA,EAAIyB,SAAS,IACb3C,EAAAA,EAAAA,GAAAT,KAAK/B,GAAYqI,IAAI3E,IACjBlB,EAAAA,EAAAA,GAAAT,KAAKhC,GAAeyI,IAAI1H,MAC1B0B,EAAAA,EAAAA,GAAAT,KAAKjC,GAAiB0E,QAAOhC,EAAAA,EAAAA,GAAAT,KAAKhC,GAAesE,IAAIvD,KACrD0B,EAAAA,EAAAA,GAAAT,KAAKhC,GAAeyE,OAAO1D,GAE/B,CACAiB,KAAKgB,MAAMC,KAAKC,KAAKG,EAAK0C,gBAC5B,CAEA2C,MAAAA,CAAO3H,EAAcE,EAAeE,IAClCe,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAE,GAAL+B,KAAAH,KAAiB,CAAEiC,IAAK,SAAUC,KAAM,CAACnD,EAAME,EAAOE,IAAU,KAC9Da,KAAK2G,aAAa5H,EAAME,EAAOE,IAEnC,CAEAwH,YAAAA,CAAa5H,EAAcE,EAAgBE,IAC5Be,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAK,GAAL4B,KAAAH,KAAkBjB,GAC1B8F,aAAe1F,CACtB,CAEAyH,SAAAA,CACE7H,EACAE,EACAE,GAEA,IAAME,GAAYa,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAI,GAAL6B,KAAAH,KAAgBjB,GAC5BoD,EAAW9C,EAAUgD,MACrBhB,GAASnB,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAK,GAAL4B,KAAAH,KAAkBX,EAAUoG,KAAK,MAEhD,GAAKN,OAAOC,UAAUC,eAAelF,KAAKkB,EAAOiE,SAAUnD,GAepD,CACL,IAAM+D,EAAO7E,EAAOiE,SAASnD,GAC7B+D,EAAKrB,aAAetD,KAAKC,OACzBtB,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAG,GAAL8B,KAAAH,KAAa,CACXiC,IAAK,kBACLC,KAAM,CAACnD,EAAMmH,EAAKrB,eAEtB,KAtBsE,CACpE,GAA+B,IAA3B7E,KAAKgB,MAAMC,KAAK1B,OAClB,MAAM,IAAIsH,MAAM,8CAElB,IAAMX,EAAa,CACjBpC,KAAM,OACNe,aAActD,KAAKC,MACnBmC,MAAM,OAAAxE,QAAA,IAAAA,OAAA,EAAAA,EAASwE,OAAQhF,EACvBoF,gBAAiB/D,KAAKgB,MAAMC,KAAKoB,OAEnChB,EAAOiE,SAASnD,GAAY+D,GAC5BhG,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAG,GAAL8B,KAAAH,KAAa,CACXiC,IAAK,iBACLC,KAAM,CAACnD,EAAMmH,IAEjB,CAQA,IAAMvE,EAAON,EAAOiE,SAASnD,GACvBL,GAAKrB,EAAAA,EAAAA,GAAAT,KAAKnC,GAAIyE,IAAIX,EAAKoC,iBAEzB9E,EAAKM,OAAS,IAChBuC,EAAGuB,MACe,iBAATpE,GACH,IAAI+D,aAAcC,OAAOhE,GACzB,IAAI6G,WAAW7G,GACnB,CAAEqE,GAAI,IAEJvE,EAAK+H,WAAW,aAClBrG,EAAAA,EAAAA,GAAAT,KAAK/B,GAAYqI,IAAIxE,GAG3B,CAEAiF,oBAAAA,CAAqBhI,EAAcE,GACjC,IAAME,GAAYe,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAI,GAAL6B,KAAAH,KAAgBjB,GAC5BM,EAAWF,EAAUkD,OACZnC,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAK,GAAL4B,KAAAH,KAAkBb,EAAUsG,KAAK,MACzCH,SAASjG,GAAYJ,EAE5B,IAAMoC,EAAQrB,KAAKgB,MAAMC,KAAK4B,QAAQ5D,EAAK8E,iBAC3C,OAAI1C,GAAS,GACXrB,KAAKgB,MAAMC,KAAK6B,OAAOzB,EAAO,GAEzBpC,CACT,CAEA+H,qBAAAA,CAAsBjI,EAAcE,IACrBiB,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAK,GAAL4B,KAAAH,KAAkBjB,GAC1B8F,aAAe5F,CACtB,CAEAoE,KAAAA,CACEtE,EACAE,EACAE,EACAE,EACA8C,GAEA,IAAMd,GAAOnB,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAM,GAAL2B,KAAAH,KAAoBjB,GAC3B4C,GAAOzB,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAK,GAAL4B,KAAAH,KAAkBqB,GAC/B,GAAkB,SAAdM,EAAKmC,KACP,MAAM,IAAI0B,EAAQ,SAAU,kBAE9B,IAAM1D,GAAKrB,EAAAA,EAAAA,GAAAT,KAAKnC,GAAIyE,IAAIX,EAAKoC,iBAC7B,IAAKjC,EACH,MAAM,IAAI0D,EAAQ,QAAS,uBAE7B,IAAMU,EAAMpE,EAAGuB,MAAM,IAAIyC,WAAW7G,EAAQE,EAAQE,GAAS,CAC3DiE,GAAInB,IAEN,OAAId,EAAKyF,WAAW,aAClBrG,EAAAA,EAAAA,GAAAT,KAAK/B,GAAYqI,IAAIxE,GAEhBoE,CACT,GA9jBA3I,EAAA,IAAA0J,QACAzJ,EAAA,IAAAyJ,QACAxJ,EAAA,IAAAwJ,QAEAvJ,EAAA,IAAAuJ,QACAtJ,EAAA,IAAAsJ,QAEArJ,EAAA,IAAAqJ,QACApJ,EAAA,IAAAoJ,QAEAnJ,EAAA,IAAAmJ,QACAlJ,EAAA,IAAAkJ,QACAjJ,EAAA,IAAAiJ,QAOAhJ,EAAA,IAAAgJ,QAxBK/I,EAAA,IAAAgJ,QA6DC/I,EAAK,kBACTgJ,EAAAA,EAAAA,GAAAnH,KAAKzC,QAAoB6J,UAAUC,QAAQC,iBAC3CH,EAAAA,EAAAA,GAAAnH,KAAKxC,QAAgB0C,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAQ,GAALyB,KAAAH,KAA2BA,KAAKuH,QAAU,CAC7D1F,QAAQ,MAEVsF,EAAAA,EAAAA,GAAAnH,KAAKvC,QAAmByC,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAQ,GAALyB,KAAAH,KAhHX,OAgHgD,CAC3DwH,MAAM/G,EAAAA,EAAAA,GAAAT,KAAKxC,GACXqE,QAAQ,MAGVsF,EAAAA,EAAAA,GAAAnH,KAAKtC,QAAiB+C,EAAAA,EAAAA,GAAAT,KAAKxC,GAAQoE,cAtHpB,YAsH8C,CAC3DC,QAAQ,MAEVsF,EAAAA,EAAAA,GAAAnH,KAAKrC,QAAkB8C,EAAAA,EAAAA,GAAAT,KAAKtC,GAAiBqE,0BAE7C,IAAMhD,EAAU,IAAI0I,aAAYhH,EAAAA,EAAAA,GAAAT,KAAKrC,GAASqG,YAC9CvD,EAAAA,EAAAA,GAAAT,KAAKrC,GAASkI,KAAK9G,EAAS,CAAEuE,GAAI,IAClC,IAAIrE,EACEE,GAAa,IAAIuI,aAAcC,OAAO5I,GAAS6I,MAAA,MAIjDvI,GAAa,EACjB,IACEJ,EAAQiE,KAAK2E,MAAM1I,EAAW,GAChC,CAAE,MAAF2I,GACE7I,EAAQ,CACNiG,KAAM,CACJpB,KAAM,YACNe,aAActD,KAAKC,MACnBmC,KAAMhF,EACN2G,SAAU,CAAC,GAEbrE,KAAM,KAGRR,EAAAA,EAAAA,GAAAT,KAAKrC,GAASyF,SAAS,IACvB3C,EAAAA,EAAAA,GAAAT,KAAKrC,GAAS0F,OAAM,IAAIL,aAAcC,OAAOC,KAAKC,UAAUlE,IAAS,CACnEqE,GAAI,IAENjE,GAAa,CACf,CACAW,KAAKgB,MAAQ/B,EAGb,IAAMkD,EAAMhD,EACT4I,MAAM,GACNC,OAAOC,SACPC,IAAKhC,GAAShD,KAAK2E,MAAM3B,IAC5B,IAAK,IAAMA,KAAS/D,EAAK,CACvB,IAAMgE,EAAA,IAAA7E,OAAiB4E,EAAMjE,IAAG,SAChC,GAA8C,mBAAnCjC,KAAKmG,GACd,IACiBnG,KAAKmG,GACbgC,KAAKnI,KADGA,IACMkG,EAAMhE,KAC7B,CAAE,MAAOkG,GACPC,QAAQC,KAAK,oCAAqCpC,EAAOkC,EAC3D,CAEJ,CAGA,IAAM/G,EAAgC,GAChCM,EAAOP,UACX,GAAkB,SAAd8E,EAAKpC,KACP,IACE,IAAMqC,QAAW1F,EAAAA,EAAAA,GAAAT,KAAKvC,GAAWmE,cAAcsE,EAAKnC,iBAC9CqE,QACJjC,EACApE,0BACFtB,EAAAA,EAAAA,GAAAT,KAAKpC,GAAIoE,IAAIkE,EAAKnC,gBAAiBoC,IAEnC1F,EAAAA,EAAAA,GAAAT,KAAKnC,GAAImE,IAAIkE,EAAKnC,gBAAiBqE,EACrC,CAAE,MAAOjC,GACPkC,QAAQE,MAAM,qCAAsCrC,EAAMC,EAC5D,MAEA,IAAK,IAAMA,KAAShB,OAAOzE,OAAOwF,EAAKZ,UACrCjE,EAAaH,KAAKS,EAAKwE,WAIvBxE,EAAK3B,KAAKgB,MAAMkE,MAGtB,IAAMpD,EAAgC,GACtC,IAAK,IAAMoE,KAAYlG,KAAKgB,MAAMC,KAChCa,EAAaZ,KAEX,IAAIC,QAAcC,WACZX,EAAAA,EAAAA,GAAAT,KAAKpC,GAAI6I,IAAIP,IACfmC,QAAQC,KAAK,2CAA4CpC,GAE3D,IAAMkC,QAAW3H,EAAAA,EAAAA,GAAAT,KAAKvC,GAAWmE,cAAcsE,GACzCsC,QACJJ,EACArG,0BACFtB,EAAAA,EAAAA,GAAAT,KAAKpC,GAAIoE,IAAIkE,EAAUkC,IACvB3H,EAAAA,EAAAA,GAAAT,KAAKnC,GAAImE,IAAIkE,EAAUsC,GACvBrC,aAKAhF,QAAQuB,IAAI,IAAIrB,KAAiBS,UAEjC9B,KAAKM,aACTjB,EAAaW,KAAKhB,gBAAkBgB,KAAKd,mBAE7C,EA6ZAd,EAAW,SAACW,EAAiBE,GAC3B,IAAME,GAASe,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAG,GAAL8B,KAAAH,KAAajB,GAC5B,IACEE,GACF,CAAE,MAAOI,GAEP,MAAAoB,EAAAA,EAAAA,GAAAT,KAAKrC,GAASyF,SAASjE,GACjBE,CACR,CACF,EAEAhB,EAAO,SAACU,GACN,IAAME,EAAYiE,KAAKC,UAAUpE,GAC3BI,GAAU,IAAI6D,aAAcC,OAAA,KAAA3B,OAAYrC,IACxCI,GAASoB,EAAAA,EAAAA,GAAAT,KAAKrC,GAASqG,UAC7B,OAAAvD,EAAAA,EAAAA,GAAAT,KAAKrC,GAAS0F,MAAMlE,EAAS,CAAEmE,GAAIjE,KACnCoB,EAAAA,EAAAA,GAAAT,KAAK/B,GAAYqI,KAAI7F,EAAAA,EAAAA,GAAAT,KAAKrC,IACnB0B,CACT,EAEAf,EAAU,SAACS,GACT,OAAOA,EAAK6I,MAAM,KAAKI,OAAOC,QAChC,EAEA1J,EAAY,SAACQ,EAAcE,GACzB,IAAME,GAAQe,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAI,GAAL6B,KAAAH,KAAgBjB,GAC1BM,EAAaJ,GAAQe,KAAKgB,MAAMkE,KACpC,IAAK,IAAM/C,KAAQhD,EAAO,CACxB,GAAkB,cAAdE,EAAKyE,KACP,MAAM,IAAI0B,EAAQ,UAAW,mBAE/B,IAAKL,OAAOC,UAAUC,eAAelF,KAAKd,EAAKiG,SAAUnD,GACvD,MAAM,IAAIqD,EAAQ,SAAU,6BAE9BnG,EAAOA,EAAKiG,SAASnD,EACvB,CACA,OAAO9C,CACT,EAEAb,EAAc,SAACO,GACb,IAAME,GAAOwB,EAAAA,EAAAA,GAAAT,KAAKjC,GAAiBuE,IAAIvD,GACvC,IAAKE,EACH,MAAM,IAAIuG,EAAQ,QAAS,uBAE7B,OAAOvG,CACT,EAEAR,EAAa,WACX,IAAMM,KAAO0J,EAAAA,EAAAA,GAAAzI,KAAKlC,GAAL2K,EACb,MAAOhI,EAAAA,EAAAA,GAAAT,KAAKjC,GAAiB0I,IAAI1H,KAC/B0J,EAAAA,EAAAA,GAAAzI,KAAKlC,GAAL2K,IAEF,OAAO1J,CACT,EAEML,EAAqB,eACzBK,EACAE,GAKA,IAAME,GAAQe,EAAAA,EAAAA,GAAAF,KAAK9B,EAAAI,GAAL6B,KAAAH,KAAgBjB,GAC1BM,GAAK,OAAAJ,QAAA,IAAAA,OAAA,EAAAA,EAASuI,QAAQ/G,EAAAA,EAAAA,GAAAT,KAAKzC,GAC/B,IAAK,IAAM4E,KAAQhD,EACjBE,QAAWA,EAAGqJ,mBAAmBvG,EAAM,CAAEN,OAAQ,OAAA5C,QAAA,IAAAA,OAAA,EAAAA,EAAS4C,SAE5D,OAAOxC,CACT,EAGF,IAAMmG,EAAN,cAAsBqB,MAEpB/H,WAAAA,CAAY6J,EAAgD5J,GAC1DU,MAAMV,GACc,iBAAT4J,EACT3I,KAAK4I,KAAOD,EACa,iBAATA,IAChB3I,KAAK4I,KAAOC,EAAAA,EAAYF,GAE5B,E","sources":["../node_modules/@electric-sql/pglite/src/fs/opfs-ahp.ts"],"sourcesContent":["import { BaseFilesystem, ERRNO_CODES, type FsStats } from './base.js'\nimport type { PostgresMod } from '../postgresMod.js'\nimport { PGlite } from '../pglite.js'\n\nexport interface OpfsAhpOptions {\n  initialPoolSize?: number\n  maintainedPoolSize?: number\n  debug?: boolean\n}\n\n// TypeScript doesn't have a built-in type for FileSystemSyncAccessHandle\nexport interface FileSystemSyncAccessHandle {\n  close(): void\n  flush(): void\n  getSize(): number\n  read(buffer: ArrayBuffer, options: { at: number }): number\n  truncate(newSize: number): void\n  write(buffer: ArrayBuffer, options: { at: number }): number\n}\n\n// State\n\nconst STATE_FILE = 'state.txt'\nconst DATA_DIR = 'data'\nconst INITIAL_MODE = {\n  DIR: 16384,\n  FILE: 32768,\n}\n\nexport interface State {\n  root: DirectoryNode\n  pool: PoolFilenames\n}\n\nexport type PoolFilenames = Array<string>\n\n// WAL\n\nexport interface WALEntry {\n  opp: string\n  args: any[]\n}\n\n// Node tree\n\nexport type NodeType = 'file' | 'directory'\n\ninterface BaseNode {\n  type: NodeType\n  lastModified: number\n  mode: number\n}\n\nexport interface FileNode extends BaseNode {\n  type: 'file'\n  backingFilename: string\n}\n\nexport interface DirectoryNode extends BaseNode {\n  type: 'directory'\n  children: { [filename: string]: Node }\n}\n\nexport type Node = FileNode | DirectoryNode\n\n/**\n * PGlite OPFS access handle pool filesystem.\n * Opens a pool of sync access handles and then allocates them as needed.\n */\nexport class OpfsAhpFS extends BaseFilesystem {\n  declare readonly dataDir: string\n  readonly initialPoolSize: number\n  readonly maintainedPoolSize: number\n\n  #opfsRootAh!: FileSystemDirectoryHandle\n  #rootAh!: FileSystemDirectoryHandle\n  #dataDirAh!: FileSystemDirectoryHandle\n\n  #stateFH!: FileSystemFileHandle\n  #stateSH!: FileSystemSyncAccessHandle\n\n  #fh: Map<string, FileSystemFileHandle> = new Map()\n  #sh: Map<string, FileSystemSyncAccessHandle> = new Map()\n\n  #handleIdCounter = 0\n  #openHandlePaths: Map<number, string> = new Map()\n  #openHandleIds: Map<string, number> = new Map()\n\n  state!: State\n  lastCheckpoint = 0\n  checkpointInterval = 1000 * 60 // 1 minute\n  poolCounter = 0\n\n  #unsyncedSH = new Set<FileSystemSyncAccessHandle>()\n\n  constructor(\n    dataDir: string,\n    {\n      initialPoolSize = 1000,\n      maintainedPoolSize = 100,\n      debug = false,\n    }: OpfsAhpOptions = {},\n  ) {\n    super(dataDir, { debug })\n    this.initialPoolSize = initialPoolSize\n    this.maintainedPoolSize = maintainedPoolSize\n  }\n\n  async init(pg: PGlite, opts: Partial<PostgresMod>) {\n    await this.#init()\n    return super.init(pg, opts)\n  }\n\n  async syncToFs(relaxedDurability = false) {\n    await this.maybeCheckpointState()\n    await this.maintainPool()\n    if (!relaxedDurability) {\n      this.flush()\n    }\n  }\n\n  async closeFs(): Promise<void> {\n    for (const sh of this.#sh.values()) {\n      sh.close()\n    }\n    this.#stateSH.flush()\n    this.#stateSH.close()\n    this.pg!.Module.FS.quit()\n  }\n\n  async #init() {\n    this.#opfsRootAh = await navigator.storage.getDirectory()\n    this.#rootAh = await this.#resolveOpfsDirectory(this.dataDir!, {\n      create: true,\n    })\n    this.#dataDirAh = await this.#resolveOpfsDirectory(DATA_DIR, {\n      from: this.#rootAh,\n      create: true,\n    })\n\n    this.#stateFH = await this.#rootAh.getFileHandle(STATE_FILE, {\n      create: true,\n    })\n    this.#stateSH = await (this.#stateFH as any).createSyncAccessHandle()\n\n    const stateAB = new ArrayBuffer(this.#stateSH.getSize())\n    this.#stateSH.read(stateAB, { at: 0 })\n    let state: State\n    const stateLines = new TextDecoder().decode(stateAB).split('\\n')\n    // Line 1 is a base state object.\n    // Lines 1+n are WAL entries.\n\n    let isNewState = false\n    try {\n      state = JSON.parse(stateLines[0])\n    } catch (e) {\n      state = {\n        root: {\n          type: 'directory',\n          lastModified: Date.now(),\n          mode: INITIAL_MODE.DIR,\n          children: {},\n        },\n        pool: [],\n      }\n      // write new state to file\n      this.#stateSH.truncate(0)\n      this.#stateSH.write(new TextEncoder().encode(JSON.stringify(state)), {\n        at: 0,\n      })\n      isNewState = true\n    }\n    this.state = state\n\n    // Apply WAL entries\n    const wal = stateLines\n      .slice(1)\n      .filter(Boolean)\n      .map((line) => JSON.parse(line))\n    for (const entry of wal) {\n      const methodName = `_${entry.opp}State`\n      if (typeof this[methodName as keyof this] === 'function') {\n        try {\n          const method = this[methodName as keyof this] as any\n          method.bind(this)(...entry.args)\n        } catch (e) {\n          console.warn('Error applying OPFS AHP WAL entry', entry, e)\n        }\n      }\n    }\n\n    // Open all file handles for dir tree\n    const walkPromises: Promise<void>[] = []\n    const walk = async (node: Node) => {\n      if (node.type === 'file') {\n        try {\n          const fh = await this.#dataDirAh.getFileHandle(node.backingFilename)\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(node.backingFilename, fh)\n\n          this.#sh.set(node.backingFilename, sh)\n        } catch (e) {\n          console.error('Error opening file handle for node', node, e)\n        }\n      } else {\n        for (const child of Object.values(node.children)) {\n          walkPromises.push(walk(child))\n        }\n      }\n    }\n    await walk(this.state.root)\n\n    // Open all pool file handles\n    const poolPromises: Promise<void>[] = []\n    for (const filename of this.state.pool) {\n      poolPromises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          if (this.#fh.has(filename)) {\n            console.warn('File handle already exists for pool file', filename)\n          }\n          const fh = await this.#dataDirAh.getFileHandle(filename)\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(filename, fh)\n          this.#sh.set(filename, sh)\n          resolve()\n        }),\n      )\n    }\n\n    await Promise.all([...walkPromises, ...poolPromises])\n\n    await this.maintainPool(\n      isNewState ? this.initialPoolSize : this.maintainedPoolSize,\n    )\n  }\n\n  async maintainPool(size?: number) {\n    size = size || this.maintainedPoolSize\n    const change = size - this.state.pool.length\n    const promises: Promise<void>[] = []\n    for (let i = 0; i < change; i++) {\n      promises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          ++this.poolCounter\n          const filename = `${(Date.now() - 1704063600).toString(16).padStart(8, '0')}-${this.poolCounter.toString(16).padStart(8, '0')}`\n          const fh = await this.#dataDirAh.getFileHandle(filename, {\n            create: true,\n          })\n          const sh: FileSystemSyncAccessHandle = await (\n            fh as any\n          ).createSyncAccessHandle()\n          this.#fh.set(filename, fh)\n          this.#sh.set(filename, sh)\n          this.#logWAL({\n            opp: 'createPoolFile',\n            args: [filename],\n          })\n          this.state.pool.push(filename)\n          resolve()\n        }),\n      )\n    }\n    for (let i = 0; i > change; i--) {\n      promises.push(\n        // eslint-disable-next-line no-async-promise-executor\n        new Promise<void>(async (resolve) => {\n          const filename = this.state.pool.pop()!\n          this.#logWAL({\n            opp: 'deletePoolFile',\n            args: [filename],\n          })\n          const fh = this.#fh.get(filename)!\n          const sh = this.#sh.get(filename)\n          sh?.close()\n          await this.#dataDirAh.removeEntry(fh.name)\n          this.#fh.delete(filename)\n          this.#sh.delete(filename)\n          resolve()\n        }),\n      )\n    }\n    await Promise.all(promises)\n  }\n\n  _createPoolFileState(filename: string) {\n    this.state.pool.push(filename)\n  }\n\n  _deletePoolFileState(filename: string) {\n    const index = this.state.pool.indexOf(filename)\n    if (index > -1) {\n      this.state.pool.splice(index, 1)\n    }\n  }\n\n  async maybeCheckpointState() {\n    if (Date.now() - this.lastCheckpoint > this.checkpointInterval) {\n      await this.checkpointState()\n    }\n  }\n\n  async checkpointState() {\n    const stateAB = new TextEncoder().encode(JSON.stringify(this.state))\n    this.#stateSH.truncate(0)\n    this.#stateSH.write(stateAB, { at: 0 })\n    this.#stateSH.flush()\n    this.lastCheckpoint = Date.now()\n  }\n\n  flush() {\n    for (const sh of this.#unsyncedSH) {\n      try {\n        sh.flush()\n      } catch (e) {\n        // The file may have been closed if it was deleted\n      }\n    }\n    this.#unsyncedSH.clear()\n  }\n\n  // Filesystem API:\n\n  chmod(path: string, mode: number): void {\n    this.#tryWithWAL({ opp: 'chmod', args: [path, mode] }, () => {\n      this._chmodState(path, mode)\n    })\n  }\n\n  _chmodState(path: string, mode: number): void {\n    const node = this.#resolvePath(path)\n    node.mode = mode\n  }\n\n  close(fd: number): void {\n    const path = this.#getPathFromFd(fd)\n    this.#openHandlePaths.delete(fd)\n    this.#openHandleIds.delete(path)\n  }\n\n  fstat(fd: number): FsStats {\n    const path = this.#getPathFromFd(fd)\n    return this.lstat(path)\n  }\n\n  lstat(path: string): FsStats {\n    const node = this.#resolvePath(path)\n    const size =\n      node.type === 'file' ? this.#sh.get(node.backingFilename)!.getSize() : 0\n    const blksize = 4096\n    return {\n      dev: 0,\n      ino: 0,\n      mode: node.mode,\n      nlink: 1,\n      uid: 0,\n      gid: 0,\n      rdev: 0,\n      size,\n      blksize,\n      blocks: Math.ceil(size / blksize),\n      atime: node.lastModified,\n      mtime: node.lastModified,\n      ctime: node.lastModified,\n    }\n  }\n\n  mkdir(path: string, options?: { recursive?: boolean; mode?: number }): void {\n    this.#tryWithWAL({ opp: 'mkdir', args: [path, options] }, () => {\n      this._mkdirState(path, options)\n    })\n  }\n\n  _mkdirState(\n    path: string,\n    options?: { recursive?: boolean; mode?: number },\n  ): void {\n    const parts = this.#pathParts(path)\n    const newDirName = parts.pop()!\n    const currentPath: string[] = []\n    let node = this.state.root\n    for (const part of parts) {\n      currentPath.push(path)\n      if (!Object.prototype.hasOwnProperty.call(node.children, part)) {\n        if (options?.recursive) {\n          this.mkdir(currentPath.join('/'))\n        } else {\n          throw new FsError('ENOENT', 'No such file or directory')\n        }\n      }\n      if (node.children[part].type !== 'directory') {\n        throw new FsError('ENOTDIR', 'Not a directory')\n      }\n      node = node.children[part] as DirectoryNode\n    }\n    if (Object.prototype.hasOwnProperty.call(node.children, newDirName)) {\n      throw new FsError('EEXIST', 'File exists')\n    }\n    const newDir: DirectoryNode = {\n      type: 'directory',\n      lastModified: Date.now(),\n      mode: options?.mode || INITIAL_MODE.DIR,\n      children: {},\n    }\n    node.children[newDirName] = newDir\n  }\n\n  open(path: string, _flags?: string, _mode?: number): number {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const handleId = this.#nextHandleId()\n    this.#openHandlePaths.set(handleId, path)\n    this.#openHandleIds.set(path, handleId)\n    return handleId\n  }\n\n  readdir(path: string): string[] {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'directory') {\n      throw new FsError('ENOTDIR', 'Not a directory')\n    }\n    return Object.keys(node.children)\n  }\n\n  read(\n    fd: number,\n    buffer: Uint8Array, // Buffer to read into\n    offset: number, // Offset in buffer to start writing to\n    length: number, // Number of bytes to read\n    position: number, // Position in file to read from\n  ): number {\n    const path = this.#getPathFromFd(fd)\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)!\n    return sh.read(new Uint8Array(buffer.buffer, offset, length), {\n      at: position,\n    })\n  }\n\n  rename(oldPath: string, newPath: string): void {\n    this.#tryWithWAL({ opp: 'rename', args: [oldPath, newPath] }, () => {\n      this._renameState(oldPath, newPath, true)\n    })\n  }\n\n  _renameState(oldPath: string, newPath: string, doFileOps = false): void {\n    const oldPathParts = this.#pathParts(oldPath)\n    const oldFilename = oldPathParts.pop()!\n    const oldParent = this.#resolvePath(oldPathParts.join('/')) as DirectoryNode\n    if (\n      !Object.prototype.hasOwnProperty.call(oldParent.children, oldFilename)\n    ) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const newPathParts = this.#pathParts(newPath)\n    const newFilename = newPathParts.pop()!\n    const newParent = this.#resolvePath(newPathParts.join('/')) as DirectoryNode\n    if (\n      doFileOps &&\n      Object.prototype.hasOwnProperty.call(newParent.children, newFilename)\n    ) {\n      // Overwrite, so return the underlying file to the pool\n      const node = newParent.children[newFilename]! as FileNode\n      const sh = this.#sh.get(node.backingFilename)!\n      sh.truncate(0)\n      this.state.pool.push(node.backingFilename)\n    }\n    newParent.children[newFilename] = oldParent.children[oldFilename]!\n    delete oldParent.children[oldFilename]\n  }\n\n  rmdir(path: string): void {\n    this.#tryWithWAL({ opp: 'rmdir', args: [path] }, () => {\n      this._rmdirState(path)\n    })\n  }\n\n  _rmdirState(path: string): void {\n    const pathParts = this.#pathParts(path)\n    const dirName = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    if (!Object.prototype.hasOwnProperty.call(parent.children, dirName)) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const node = parent.children[dirName]!\n    if (node.type !== 'directory') {\n      throw new FsError('ENOTDIR', 'Not a directory')\n    }\n    if (Object.keys(node.children).length > 0) {\n      throw new FsError('ENOTEMPTY', 'Directory not empty')\n    }\n    delete parent.children[dirName]\n  }\n\n  truncate(path: string, len = 0): void {\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)\n    if (!sh) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    sh.truncate(len)\n    this.#unsyncedSH.add(sh)\n  }\n\n  unlink(path: string): void {\n    this.#tryWithWAL({ opp: 'unlink', args: [path] }, () => {\n      this._unlinkState(path, true)\n    })\n  }\n\n  _unlinkState(path: string, doFileOps = false): void {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const dir = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    if (!Object.prototype.hasOwnProperty.call(dir.children, filename)) {\n      throw new FsError('ENOENT', 'No such file or directory')\n    }\n    const node = dir.children[filename]!\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    delete dir.children[filename]\n    if (doFileOps) {\n      const sh = this.#sh.get(node.backingFilename)!\n      // We don't delete the file, it's truncated and returned to the pool\n      sh?.truncate(0)\n      this.#unsyncedSH.add(sh)\n      if (this.#openHandleIds.has(path)) {\n        this.#openHandlePaths.delete(this.#openHandleIds.get(path)!)\n        this.#openHandleIds.delete(path)\n      }\n    }\n    this.state.pool.push(node.backingFilename)\n  }\n\n  utimes(path: string, atime: number, mtime: number): void {\n    this.#tryWithWAL({ opp: 'utimes', args: [path, atime, mtime] }, () => {\n      this._utimesState(path, atime, mtime)\n    })\n  }\n\n  _utimesState(path: string, _atime: number, mtime: number): void {\n    const node = this.#resolvePath(path)\n    node.lastModified = mtime\n  }\n\n  writeFile(\n    path: string,\n    data: string | Uint8Array,\n    options?: { encoding?: string; mode?: number; flag?: string },\n  ): void {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n\n    if (!Object.prototype.hasOwnProperty.call(parent.children, filename)) {\n      if (this.state.pool.length === 0) {\n        throw new Error('No more file handles available in the pool')\n      }\n      const node: Node = {\n        type: 'file',\n        lastModified: Date.now(),\n        mode: options?.mode || INITIAL_MODE.FILE,\n        backingFilename: this.state.pool.pop()!,\n      }\n      parent.children[filename] = node\n      this.#logWAL({\n        opp: 'createFileNode',\n        args: [path, node],\n      })\n    } else {\n      const node = parent.children[filename] as FileNode\n      node.lastModified = Date.now()\n      this.#logWAL({\n        opp: 'setLastModified',\n        args: [path, node.lastModified],\n      })\n    }\n    const node = parent.children[filename] as FileNode\n    const sh = this.#sh.get(node.backingFilename)!\n    // Files in pool are empty, only write if data is provided\n    if (data.length > 0) {\n      sh.write(\n        typeof data === 'string'\n          ? new TextEncoder().encode(data)\n          : new Uint8Array(data),\n        { at: 0 },\n      )\n      if (path.startsWith('/pg_wal')) {\n        this.#unsyncedSH.add(sh)\n      }\n    }\n  }\n\n  _createFileNodeState(path: string, node: FileNode): FileNode {\n    const pathParts = this.#pathParts(path)\n    const filename = pathParts.pop()!\n    const parent = this.#resolvePath(pathParts.join('/')) as DirectoryNode\n    parent.children[filename] = node\n    // remove backingFilename from pool\n    const index = this.state.pool.indexOf(node.backingFilename)\n    if (index > -1) {\n      this.state.pool.splice(index, 1)\n    }\n    return node\n  }\n\n  _setLastModifiedState(path: string, lastModified: number): void {\n    const node = this.#resolvePath(path)\n    node.lastModified = lastModified\n  }\n\n  write(\n    fd: number,\n    buffer: Uint8Array, // Buffer to read from\n    offset: number, // Offset in buffer to start reading from\n    length: number, // Number of bytes to write\n    position: number, // Position in file to write to\n  ): number {\n    const path = this.#getPathFromFd(fd)\n    const node = this.#resolvePath(path)\n    if (node.type !== 'file') {\n      throw new FsError('EISDIR', 'Is a directory')\n    }\n    const sh = this.#sh.get(node.backingFilename)\n    if (!sh) {\n      throw new FsError('EBADF', 'Bad file descriptor')\n    }\n    const ret = sh.write(new Uint8Array(buffer, offset, length), {\n      at: position,\n    })\n    if (path.startsWith('/pg_wal')) {\n      this.#unsyncedSH.add(sh)\n    }\n    return ret\n  }\n\n  // Internal methods:\n\n  #tryWithWAL(entry: WALEntry, fn: () => void) {\n    const offset = this.#logWAL(entry)\n    try {\n      fn()\n    } catch (e) {\n      // Rollback WAL entry\n      this.#stateSH.truncate(offset)\n      throw e\n    }\n  }\n\n  #logWAL(entry: WALEntry) {\n    const entryJSON = JSON.stringify(entry)\n    const stateAB = new TextEncoder().encode(`\\n${entryJSON}`)\n    const offset = this.#stateSH.getSize()\n    this.#stateSH.write(stateAB, { at: offset })\n    this.#unsyncedSH.add(this.#stateSH)\n    return offset\n  }\n\n  #pathParts(path: string): string[] {\n    return path.split('/').filter(Boolean)\n  }\n\n  #resolvePath(path: string, from?: DirectoryNode): Node {\n    const parts = this.#pathParts(path)\n    let node: Node = from || this.state.root\n    for (const part of parts) {\n      if (node.type !== 'directory') {\n        throw new FsError('ENOTDIR', 'Not a directory')\n      }\n      if (!Object.prototype.hasOwnProperty.call(node.children, part)) {\n        throw new FsError('ENOENT', 'No such file or directory')\n      }\n      node = node.children[part]!\n    }\n    return node\n  }\n\n  #getPathFromFd(fd: number): string {\n    const path = this.#openHandlePaths.get(fd)\n    if (!path) {\n      throw new FsError('EBADF', 'Bad file descriptor')\n    }\n    return path\n  }\n\n  #nextHandleId(): number {\n    const id = ++this.#handleIdCounter\n    while (this.#openHandlePaths.has(id)) {\n      this.#handleIdCounter++\n    }\n    return id\n  }\n\n  async #resolveOpfsDirectory(\n    path: string,\n    options?: {\n      from?: FileSystemDirectoryHandle\n      create?: boolean\n    },\n  ): Promise<FileSystemDirectoryHandle> {\n    const parts = this.#pathParts(path)\n    let ah = options?.from || this.#opfsRootAh\n    for (const part of parts) {\n      ah = await ah.getDirectoryHandle(part, { create: options?.create })\n    }\n    return ah\n  }\n}\n\nclass FsError extends Error {\n  code?: number\n  constructor(code: number | keyof typeof ERRNO_CODES | null, message: string) {\n    super(message)\n    if (typeof code === 'number') {\n      this.code = code\n    } else if (typeof code === 'string') {\n      this.code = ERRNO_CODES[code]\n    }\n  }\n}\n"],"names":["R","H","v","F","M","y","b","m","x","P","D","S","n","C","O","k","w","f","I","W","j","T","L","B","constructor","e","initialPoolSize","t","maintainedPoolSize","o","debug","i","arguments","length","undefined","super","g","Map","lastCheckpoint","checkpointInterval","poolCounter","Set","this","init","r","call","syncToFs","maybeCheckpointState","maintainPool","flush","closeFs","s","values","close","pg","Module","FS","quit","state","pool","push","Promise","async","a","concat","Date","now","toString","padStart","h","getFileHandle","create","d","createSyncAccessHandle","set","opp","args","c","_s$get","pop","get","removeEntry","name","delete","all","_createPoolFileState","_deletePoolFileState","indexOf","splice","checkpointState","TextEncoder","encode","JSON","stringify","truncate","write","at","_unused","clear","chmod","_chmodState","mode","fstat","lstat","type","backingFilename","getSize","dev","ino","nlink","uid","gid","rdev","size","blksize","blocks","Math","ceil","atime","lastModified","mtime","ctime","mkdir","_mkdirState","root","Object","prototype","hasOwnProperty","children","recursive","p","join","open","readdir","keys","read","Uint8Array","buffer","rename","_renameState","l","u","rmdir","_rmdirState","add","unlink","_unlinkState","has","utimes","_utimesState","writeFile","Error","startsWith","_createFileNodeState","_setLastModifiedState","WeakMap","WeakSet","E","navigator","storage","getDirectory","dataDir","from","ArrayBuffer","TextDecoder","decode","split","parse","_unused2","slice","filter","Boolean","map","bind","N","console","warn","error","U","_","getDirectoryHandle","A","code","z"],"sourceRoot":""}